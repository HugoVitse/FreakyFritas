import { useCallback, useMemo, useRef, useState } from 'react';
import { StatusBar, StyleSheet, Text, TouchableOpacity, View, ScrollView, TextInput } from 'react-native';
import { CameraView, useCameraPermissions } from 'expo-camera';
import * as Haptics from 'expo-haptics';
import { SafeAreaView } from 'react-native-safe-area-context';
import { manipulateAsync, SaveFormat } from 'expo-image-manipulator';

type ParsedFields = {
  product_name?: string | null;
  variety?: string | null;
  calibre?: string | null;
  category?: string | null;
  piece_count?: string | number | null;
  origin?: string | null;
  lots?: string | null;
  traceability_code?: string | null;
  packer_name_address?: string | null;
  packer_iso_code?: string | null;
  packed_for_name_address?: string | null;
  packed_for_packer_code?: string | null;
  net_weight?: string | null;
};

type ScanResult = {
  image: string;
  raw: string;
  parsed: ParsedFields;
  compliance?: {
    ok: boolean;
    missing: string[];
  };
  isLoading?: boolean;
  base64?: string;
};

type DeliveryItem = {
  product_name: string | null;
  variety: string | null;
  quantity: number | null;
  unit: string | null;
  lot: string | null;
  origin: string | null;
};

type DeliveryNote = {
  shipper_name_address: string | null;
  shipper_siret: string | null;
  delivery_note_number: string | null;
  delivery_date: string | null;
  recipient_name_address: string | null;
  recipient_siret: string | null;
  items: DeliveryItem[];
};

type WorkflowStep = 'home' | 'bl-scan' | 'labels-scan' | 'summary';

type CurrentDelivery = {
  step: WorkflowStep;
  blData: DeliveryNote | null;
  scannedLabels: ScanResult[];
  labelCounts: Record<string, number>;
  startedAt: number;
};

const API_URL = process.env.EXPO_PUBLIC_API_URL ?? 'http://localhost:8000';

export default function App() {
  const [permission, requestPermission] = useCameraPermissions();
  const cameraRef = useRef<CameraView | null>(null);
  const capturingRef = useRef(false);

  // Workflow principal
  const [currentDelivery, setCurrentDelivery] = useState<CurrentDelivery>({
    step: 'home',
    blData: null,
    scannedLabels: [],
    labelCounts: {},
    startedAt: 0,
  });

  // States UI
  const [flash, setFlash] = useState<'on' | 'off'>('off');
  const [isCapturing, setIsCapturing] = useState(false);
  const [uploadingCount, setUploadingCount] = useState(0);
  const [error, setError] = useState<string | null>(null);
  
  // States pour les modals et d√©tails
  const [lastScan, setLastScan] = useState<ScanResult | null>(null);
  const [historyOpen, setHistoryOpen] = useState(false);
  const [expandedIndex, setExpandedIndex] = useState<number | null>(null);
  const [blModalOpen, setBlModalOpen] = useState(false);
  const [quantityModalOpen, setQuantityModalOpen] = useState(false);
  const [quantityModalProduct, setQuantityModalProduct] = useState<string | null>(null);
  const [bottomPanelCollapsed, setBottomPanelCollapsed] = useState(false);
  const [quantityInput, setQuantityInput] = useState<string>('1');

  const needPermission = !permission?.granted;

  // Getters pour acc√©der aux donn√©es du workflow actuel
  const blData = currentDelivery.blData;
  const scannedLabels = currentDelivery.scannedLabels;
  const labelCounts = currentDelivery.labelCounts;
  const currentStep = currentDelivery.step;

  // Fonctions de navigation du workflow
  const startNewDelivery = useCallback(() => {
    setCurrentDelivery({
      step: 'bl-scan',
      blData: null,
      scannedLabels: [],
      labelCounts: {},
      startedAt: Date.now(),
    });
    setLastScan(null);
    setHistoryOpen(false);
    setError(null);
  }, []);

  const goToLabelsScan = useCallback(() => {
    setCurrentDelivery((prev) => ({
      ...prev,
      step: 'labels-scan',
    }));
    setLastScan(null);
    setHistoryOpen(false);
    setError(null);
  }, []);

  const goToSummary = useCallback(() => {
    setCurrentDelivery((prev) => ({
      ...prev,
      step: 'summary',
    }));
  }, []);

  const goBackHome = useCallback(() => {
    setCurrentDelivery({
      step: 'home',
      blData: null,
      scannedLabels: [],
      labelCounts: {},
      startedAt: 0,
    });
    setLastScan(null);
    setHistoryOpen(false);
    setError(null);
  }, []);

  const getCurrentMode = (): 'bl' | 'labels' => {
    return currentStep === 'bl-scan' ? 'bl' : 'labels';
  };

  const getHistory = (): ScanResult[] => {
    return currentStep === 'bl-scan' ? [] : scannedLabels;
  };

  const permissionView = useMemo(() => {
    if (!permission) {
      return (
        <View style={styles.centered}>
          <Text style={styles.title}>Chargement des permissions...</Text>
        </View>
      );
    }

    if (needPermission) {
      return (
        <View style={styles.centered}>
          <Text style={styles.title}>Autorisez l‚Äôacc√®s √† la cam√©ra</Text>
          <TouchableOpacity style={styles.primaryButton} onPress={requestPermission}>
            <Text style={styles.primaryButtonText}>Autoriser</Text>
          </TouchableOpacity>
        </View>
      );
    }

    return null;
  }, [needPermission, permission, requestPermission]);

  const uploadLabel = useCallback(async (photoBase64: string, filename: string) => {
    setUploadingCount((c) => c + 1);
    setError(null);

    // Ajouter imm√©diatement l'image en historique avec isLoading=true
    const loadingItem: ScanResult = {
      image: '',
      raw: 'Chargement...',
      parsed: {},
      compliance: { ok: false, missing: [] },
      isLoading: true,
      base64: photoBase64,
    };
    setCurrentDelivery((prev) => ({
      ...prev,
      scannedLabels: [loadingItem, ...prev.scannedLabels].slice(0, 20),
    }));
    setLastScan(loadingItem);

    try {
      const payload = {
        image_base64: photoBase64,
        filename,
        use_paddle: true,
        use_llm: true, // backend avec OPENAI_API_KEY
      };

      const endpoint = `${API_URL}/scan`;
      console.log('API call ->', endpoint);
      const res = await fetch(endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });

      if (!res.ok) {
        const msg = await res.text();
        console.error('API error', res.status, msg);
        throw new Error(msg || `Erreur HTTP ${res.status}`);
      }

      const data = (await res.json()) as { parsed?: ParsedFields; image?: string; raw?: string };
      console.log('API success, parsed keys:', Object.keys(data.parsed ?? {}));
      const parsed = data.parsed ?? {};
      const missing = [
        ['product_name', 'Produit'],
        ['origin', 'Origine'],
        ['category', 'Cat√©gorie'],
        ['calibre', 'Calibre'],
        ['lots', 'Lot'],
      ]
        .filter(([key]) => !parsed[key as keyof ParsedFields])
        .map(([, label]) => label);
      const compliance = { ok: missing.length === 0, missing };
      const normalized = {
        image: data.image ?? '',
        raw: data.raw ?? '',
        parsed,
        compliance,
        base64: photoBase64,
      };
      setLastScan(normalized);
      // Remplacer le premier √©l√©ment (celui en chargement) par le r√©sultat final
      setCurrentDelivery((prev) => {
        const updated = [...prev.scannedLabels];
        if (updated[0]?.isLoading) {
          updated[0] = normalized;
        }
        return {
          ...prev,
          scannedLabels: updated,
        };
      });
      const key = (parsed.product_name ?? '').toUpperCase().trim();
      if (key) {
        setCurrentDelivery((prev) => ({
          ...prev,
          labelCounts: {
            ...prev.labelCounts,
            [key]: (prev.labelCounts[key] ?? 0) + 1,
          },
        }));
      }
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success).catch(() => {});
    } catch (e: any) {
      console.error('Upload error', e);
      setError(e?.message ?? 'Erreur inconnue');
      // Retirer l'item en chargement en cas d'erreur
      setCurrentDelivery((prev) => ({
        ...prev,
        scannedLabels: prev.scannedLabels.filter((item) => !item.isLoading),
      }));
      setLastScan(null);
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error).catch(() => {});
    } finally {
      setUploadingCount((c) => Math.max(0, c - 1));
    }
  }, []);

  const uploadDelivery = useCallback(async (photoBase64: string, filename: string) => {
    setUploadingCount((c) => c + 1);
    setError(null);
    try {
      const payload = {
        image_base64: photoBase64,
        filename,
        use_llm: true,
        use_paddle: true, // Utilise PaddleOCR pour BL
      };

      const endpoint = `${API_URL}/scan-bl`;
      console.log('API call BL ->', endpoint);
      const res = await fetch(endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });

      if (!res.ok) {
        const msg = await res.text();
        console.error('API error BL', res.status, msg);
        throw new Error(msg || `Erreur HTTP ${res.status}`);
      }

      const data = (await res.json()) as { parsed?: DeliveryNote; raw?: string };
      console.log('API BL success, items:', data.parsed?.items?.length ?? 0);
      const newDelivery = data.parsed ?? {
        shipper_name_address: null,
        shipper_siret: null,
        delivery_note_number: null,
        delivery_date: null,
        recipient_name_address: null,
        recipient_siret: null,
        items: [],
      };
      setCurrentDelivery((prev) => ({
        ...prev,
        blData: newDelivery,
        labelCounts: {}, // R√©initialise les compteurs
      }));
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success).catch(() => {});
    } catch (e: any) {
      console.error('Upload BL error', e);
      setError(e?.message ?? 'Erreur BL inconnue');
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error).catch(() => {});
    } finally {
      setUploadingCount((c) => Math.max(0, c - 1));
    }
  }, []);

  const handleValidateBlScan = useCallback(() => {
    // Fonction appel√©e quand on valide la fin de scan du BL
    if (!blData) return;
    
    console.log('BL validation:', {
      delivery_note_number: blData.delivery_note_number,
      total_items: blData.items.length,
      label_counts: labelCounts,
    });

    setError(null);
    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success).catch(() => {});
    
    // Passer √† l'√©tape suivante (scan des √©tiquettes)
    setTimeout(() => {
      goToLabelsScan();
    }, 300);
  }, [blData, labelCounts, goToLabelsScan]);

  const handleAddQuantity = useCallback(() => {
    // Fonction pour ajouter une quantit√© manuelle
    if (!quantityModalProduct) return;
    
    const qty = parseInt(quantityInput, 10);
    if (isNaN(qty) || qty <= 0) {
      setError('Veuillez entrer une quantit√© valide');
      return;
    }

    const key = quantityModalProduct.toUpperCase().trim();
    setCurrentDelivery((prev) => ({
      ...prev,
      labelCounts: {
        ...prev.labelCounts,
        [key]: (prev.labelCounts[key] ?? 0) + qty,
      },
    }));

    console.log(`Quantit√© ajout√©e: ${key} +${qty}`);
    
    // Haptic feedback
    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success).catch(() => {});
    
    // Fermer modal et r√©initialiser
    setQuantityModalOpen(false);
    setQuantityModalProduct(null);
    setQuantityInput('1');
    setError(null);
  }, [quantityModalProduct, quantityInput]);

  const handleCapture = useCallback(async () => {
    if (!cameraRef.current || capturingRef.current) return;
    setError(null);
    setIsCapturing(true);
    capturingRef.current = true;
    try {
      console.log('Capture: start');
      const photo = await cameraRef.current.takePictureAsync({
        base64: true,
        quality: 1, // meilleure qualit√©
        skipProcessing: false, // laisser le post-traitement (sharpen, etc.)
      });
      capturingRef.current = false;
      setIsCapturing(false);

      if (!photo?.base64) {
        throw new Error('La photo n‚Äôa pas pu √™tre encod√©e en base64.');
      }

      console.log('Capture: photo ok, size base64 ~', photo.base64.length);
      const filenameBase = photo.uri?.split('/').pop() ?? 'capture.jpg';

      if (mode === 'labels') {
        // Rogner selon un cadrant central (cadre affich√© √† l‚Äô√©cran)
        const cropWidth = photo.width * 0.8;
        const cropHeight = photo.height * 0.5;
        const crop = {
          originX: (photo.width - cropWidth) / 2,
          originY: (photo.height - cropHeight) / 2,
          width: cropWidth,
          height: cropHeight,
        };

        const cropped = await manipulateAsync(photo.uri, [{ crop }], {
          compress: 0.95,
          format: SaveFormat.JPEG,
          base64: true,
        });

        if (!cropped.base64) {
          throw new Error('Le rognage a √©chou√©.');
        }

        const filename = filenameBase.replace(/\.jpg$/i, '_crop.jpg');
        // Lancement de l‚Äôupload async sans bloquer les prochaines captures
        uploadLabel(cropped.base64, filename);
      } else {
        // Mode BL: on envoie la page compl√®te, sans rognage
        uploadDelivery(photo.base64, filenameBase);
      }
    } catch (e: any) {
      capturingRef.current = false;
      setIsCapturing(false);
      console.error('Capture error', e);
      setError(e?.message ?? 'Erreur inconnue');
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error).catch(() => {});
    }
  }, [mode, uploadDelivery, uploadLabel]);

  if (permissionView) {
    return <SafeAreaView style={styles.container}>{permissionView}</SafeAreaView>;
  }

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar barStyle="light-content" />
      <View style={styles.cameraWrapper}>
        <CameraView
          style={styles.camera}
          facing="back"
          flash={flash}
          ref={(ref) => {
            cameraRef.current = ref;
          }}
        />
        <View style={styles.overlay}>
          <Text style={styles.title}>
            {mode === 'labels' ? 'Photographiez l‚Äô√©tiquette' : 'Photographiez le bon de livraison'}
          </Text>
          <Text style={styles.subtitle}>
            {mode === 'labels'
              ? 'Placez l‚Äô√©tiquette au centre, √©vitez le flou'
              : 'Cadrez la page enti√®re, bien nette'}
          </Text>
        </View>
        {mode === 'labels' && <View style={styles.guideFrame} pointerEvents="none" />}
        <View style={styles.captureZone}>
          <TouchableOpacity
            style={[styles.shutter, (isCapturing || uploadingCount > 0) && styles.shutterDisabled]}
            onPress={handleCapture}
            disabled={isCapturing}
          >
            <Text style={styles.shutterText}>{isCapturing ? 'CAPTURE...' : 'CAPTURER'}</Text>
          </TouchableOpacity>
          {uploadingCount > 0 && (
            <Text style={styles.uploadingInfo}>Envoi en cours : {uploadingCount}</Text>
          )}
        </View>
      </View>

      <View style={[styles.bottomPanel, bottomPanelCollapsed && styles.bottomPanelCollapsed]}>
        <TouchableOpacity 
          style={styles.bottomPanelToggle}
          onPress={() => setBottomPanelCollapsed(!bottomPanelCollapsed)}
        >
          <Text style={styles.bottomPanelToggleText}>
            {bottomPanelCollapsed ? '‚ñ≤ Afficher' : '‚ñº R√©duire'}
          </Text>
        </TouchableOpacity>

        {!bottomPanelCollapsed && (
        <>
        <View style={styles.row}>
          <Text style={styles.label}>Mode</Text>
          <View style={styles.modeSwitch}>
            <TouchableOpacity
              style={[styles.modeChip, mode === 'bl' && styles.modeChipActive]}
              onPress={() => setMode('bl')}
            >
              <Text style={styles.modeChipText}>Bon de livraison</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.modeChip, mode === 'labels' && styles.modeChipActive]}
              onPress={() => setMode('labels')}
            >
              <Text style={styles.modeChipText}>√âtiquettes</Text>
            </TouchableOpacity>
          </View>
        </View>

        <View style={styles.row}>
          <Text style={styles.label}>Lampe</Text>
          <TouchableOpacity
            style={[styles.chip, flash === 'on' && styles.chipActive]}
            onPress={() => setFlash((prev) => (prev === 'on' ? 'off' : 'on'))}
          >
            <Text style={styles.chipText}>{flash === 'on' ? 'Allum√©e' : '√âteinte'}</Text>
          </TouchableOpacity>
        </View>

        {error && <Text style={styles.error}>{error}</Text>}

        <View style={styles.separator} />

        {delivery && (
          <TouchableOpacity
            style={styles.deliveryCard}
            onPress={() => setBlModalOpen(true)}
          >
            <Text style={styles.deliveryTitle}>Bon de livraison courant</Text>
            <Text style={styles.deliveryMeta}>{delivery.delivery_note_number ?? 'BL sans num√©ro'}</Text>
            <Text style={styles.deliveryMeta}>{delivery.shipper_name_address ?? 'Exp√©diteur inconnu'}</Text>
            <Text style={styles.deliveryMeta}>{delivery.recipient_name_address ?? 'Destinataire inconnu'}</Text>
            {delivery.items.slice(0, 4).map((it, idx) => (
              <Text key={idx} style={styles.deliveryItem}>
                - {it.product_name || 'Produit'} : {it.quantity ?? '?'} {it.unit ?? ''}
              </Text>
            ))}
            {delivery.items.length > 4 && (
              <Text style={styles.deliveryMeta}>+ {delivery.items.length - 4} lignes suppl√©mentaires‚Ä¶</Text>
            )}
            <Text style={{marginTop: 8, fontStyle: 'italic', color: '#9ca3af', fontSize: 12}}>üëÜ Appuyez pour voir en d√©tail</Text>
          </TouchableOpacity>
        )}

        {mode === 'bl' && blHistory ? (
          <>
            <View style={styles.row}>
              <Text style={styles.label}>Livraison : {blHistory.delivery_note_number ?? 'BL sans num√©ro'}</Text>
              <TouchableOpacity onPress={() => setHistoryOpen((v) => !v)}>
                <Text style={styles.link}>{historyOpen ? 'R√©duire' : 'Voir items'}</Text>
              </TouchableOpacity>
            </View>
            {historyOpen && (
              <View style={styles.historyBox}>
                <Text style={styles.historyTitle}>Items √† scanner</Text>
                <ScrollView style={styles.historyList} contentContainerStyle={styles.historyContent}>
                  {blHistory.items.map((item, idx) => {
                    const key = (item.product_name ?? '').toUpperCase().trim();
                    const scanned = key ? labelCounts[key] ?? 0 : 0;
                    const expected = item.quantity ?? 0;
                    const isOk = scanned >= expected;
                    return (
                      <View
                        key={idx}
                        style={styles.historyItem}
                      >
                        <View style={styles.historyHeader}>
                          <View style={[styles.badge, isOk ? styles.badgeOk : styles.badgeKo]} />
                          <Text style={styles.historyProduct}>{item.product_name ?? 'Produit'}</Text>
                        </View>
                        <Text style={styles.historyMeta}>
                          Vari√©t√©: {item.variety ?? '‚Äî'} ‚Ä¢ Origine: {item.origin ?? '‚Äî'}
                        </Text>
                        <Text style={styles.historyMeta}>
                          Lot: {item.lot ?? '‚Äî'} ‚Ä¢ Unit√©: {item.unit ?? ''}
                        </Text>
                        <View style={styles.quantityRow}>
                          <Text style={[styles.historyMeta, isOk ? {color: '#22c55e'} : {color: '#ef4444'}]}>
                            Scann√©es: {scanned} / Attendues: {expected}
                          </Text>
                          {key && (
                            <View style={styles.quantityControls}>
                              <TouchableOpacity
                                style={[styles.quantityButton, styles.quantityButtonSmall]}
                                onPress={() => {
                                  if (scanned > 0) {
                                    setLabelCounts((prev) => ({
                                      ...prev,
                                      [key]: prev[key] - 1,
                                    }));
                                  }
                                }}
                              >
                                <Text style={styles.quantityButtonText}>‚àí</Text>
                              </TouchableOpacity>
                              <TouchableOpacity
                                style={[styles.quantityButton, styles.quantityButtonSmall]}
                                onPress={() => {
                                  setQuantityModalProduct(item.product_name);
                                  setQuantityInput('1');
                                  setQuantityModalOpen(true);
                                }}
                              >
                                <Text style={styles.quantityButtonText}>+</Text>
                              </TouchableOpacity>
                            </View>
                          )}
                        </View>
                      </View>
                    );
                  })}
                </ScrollView>
              </View>
            )}
          </>
        ) : mode === 'labels' ? (
          <>
            <View style={styles.row}>
              <Text style={styles.label}>Dernier r√©sultat √©tiquette</Text>
              <TouchableOpacity onPress={() => setHistoryOpen((v) => !v)}>
                <Text style={styles.link}>{historyOpen ? 'R√©duire' : 'Voir historique'}</Text>
              </TouchableOpacity>
            </View>
            {lastScan ? (
              <View style={styles.scanCard}>
                {lastScan.isLoading ? (
                  <>
                    <Text style={styles.scanType}>‚è≥ Chargement de l'OCR...</Text>
                    <Text style={styles.scanData}>Merci de patienter, l'image est en cours de traitement</Text>
                  </>
                ) : (
                  <>
                    <View style={{flexDirection: 'row', justifyContent: 'space-between', alignItems: 'flex-start', gap: 8}}>
                      <View style={{flex: 1}}>
                        <Text style={styles.scanType}>{lastScan.parsed?.product_name ?? 'Produit inconnu'}</Text>
                        <Text style={styles.scanData}>
                          Origine: {lastScan.parsed?.origin ?? '‚Äî'} ¬∑ Calibre: {lastScan.parsed?.calibre ?? '‚Äî'} ¬∑ Cat: {lastScan.parsed?.category ?? '‚Äî'}
                        </Text>
                        <Text style={styles.scanTime}>Lot: {lastScan.parsed?.lots ?? '‚Äî'} ¬∑ Tra√ßabilit√©: {lastScan.parsed?.traceability_code ?? '‚Äî'}</Text>
                      </View>
                      {(() => {
                        const key = (lastScan.parsed?.product_name ?? '').toUpperCase().trim();
                        if (!key) return null;
                        return (
                          <TouchableOpacity
                            style={[styles.quantityButton, styles.quantityButtonSmall]}
                            onPress={() => {
                              setQuantityModalProduct(lastScan.parsed?.product_name ?? key);
                              setQuantityInput('1');
                              setQuantityModalOpen(true);
                            }}
                          >
                            <Text style={styles.quantityButtonText}>+</Text>
                          </TouchableOpacity>
                        );
                      })()}
                    </View>
                    <View style={styles.complianceRow}>
                      <View style={[styles.badge, lastScan.compliance?.ok ? styles.badgeOk : styles.badgeKo]} />
                      <Text style={styles.complianceText}>
                        {lastScan.compliance?.ok
                          ? 'Conforme (champs cl√©s pr√©sents)'
                          : `Non conforme : ${lastScan.compliance?.missing.join(', ') || 'champs manquants'}`}
                      </Text>
                    </View>
                  </>
                )}
              </View>
            ) : (
              <Text style={styles.muted}>Aucun scan pour le moment</Text>
            )}

            {historyOpen && history.length > 0 && (
              <View style={styles.historyBox}>
                <Text style={styles.historyTitle}>Historique</Text>
                <ScrollView style={styles.historyList} contentContainerStyle={styles.historyContent}>
                  {history.map((item, idx) => {
                    const expanded = expandedIndex === idx;
                    const key = (item.parsed?.product_name ?? '').toUpperCase().trim();
                    const scanned = key ? labelCounts[key] ?? 0 : 0;
                    return (
                      <View
                        key={`${item.parsed?.product_name ?? 'prod'}-${idx}`}
                        style={styles.historyItem}
                      >
                        <TouchableOpacity
                          onPress={() => setExpandedIndex(expanded ? null : idx)}
                          style={{flex: 1}}
                        >
                          <View style={styles.historyHeader}>
                            {item.isLoading ? (
                              <View style={[styles.badge, {backgroundColor: '#6b7280', opacity: 0.5}]} />
                            ) : (
                              <View style={[styles.badge, item.compliance?.ok ? styles.badgeOk : styles.badgeKo]} />
                            )}
                            <Text style={styles.historyProduct}>
                              {item.isLoading ? '‚è≥ Chargement...' : item.parsed?.product_name ?? 'Produit'}
                            </Text>
                          </View>
                          {!item.isLoading && (
                            <>
                              <Text style={styles.historyMeta}>
                                Origine {item.parsed?.origin ?? '‚Äî'} ‚Ä¢ Calibre {item.parsed?.calibre ?? '‚Äî'} ‚Ä¢ Cat {item.parsed?.category ?? '‚Äî'}
                              </Text>
                              <Text style={styles.historyMeta}>Lot {item.parsed?.lots ?? '‚Äî'} ‚Ä¢ Tra√ßabilit√© {item.parsed?.traceability_code ?? '‚Äî'}</Text>
                              {(() => {
                                const expected =
                                  delivery?.items?.find(
                                    (it) => it.product_name && it.product_name.toUpperCase().includes(key),
                                  )?.quantity ?? null;
                                if (!key || expected == null) {
                                  return null;
                                }
                                return (
                                  <Text style={styles.historyMeta}>
                                    √âtiquettes scann√©es: {scanned} / {expected}
                                  </Text>
                                );
                              })()}
                              <Text style={styles.historyMeta}>
                                {item.compliance?.ok
                                  ? 'Conforme'
                                  : `Non conforme : ${item.compliance?.missing.join(', ') || 'champs manquants'}`}
                              </Text>
                            </>
                          )}
                        </TouchableOpacity>

                        {!item.isLoading && key && (
                          <View style={styles.quantityControls}>
                            <TouchableOpacity
                              style={[styles.quantityButton, styles.quantityButtonSmall]}
                              onPress={() => {
                                setQuantityModalProduct(item.parsed?.product_name ?? key);
                                setQuantityInput('1');
                                setQuantityModalOpen(true);
                              }}
                            >
                              <Text style={styles.quantityButtonText}>+</Text>
                            </TouchableOpacity>
                          </View>
                        )}

                        {expanded && !item.isLoading && (
                          <View style={styles.expandedBox}>
                            {[
                              ['Produit', item.parsed?.product_name],
                              ['Vari√©t√©', item.parsed?.variety],
                              ['Origine', item.parsed?.origin],
                              ['Cat√©gorie', item.parsed?.category],
                              ['Calibre', item.parsed?.calibre],
                              ['Nombre', item.parsed?.piece_count],
                              ['Lot', item.parsed?.lots],
                              ['Tra√ßabilit√©', item.parsed?.traceability_code],
                              ['Poids net', item.parsed?.net_weight],
                              ['Emballeur', item.parsed?.packer_name_address],
                              ['Code emballeur', item.parsed?.packer_iso_code],
                              ['Emball√© pour', item.parsed?.packed_for_name_address],
                            ].map(([label, value]) => (
                              <Text key={label} style={styles.expandedRow}>
                                {label}: {value ?? '‚Äî'}
                              </Text>
                            ))}
                          </View>
                        )}
                      </View>
                    );
                  })}
                </ScrollView>
              </View>
            )}
          </>
        ) : null}
        </>
        )}
      </View>

      {/* Modal affichage BL d√©taill√© */}
      {blModalOpen && delivery && (
        <View style={styles.modalOverlay}>
          <View style={styles.modal}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>D√©tail du bon de livraison</Text>
              <TouchableOpacity onPress={() => setBlModalOpen(false)}>
                <Text style={styles.modalCloseButton}>‚úï</Text>
              </TouchableOpacity>
            </View>

            <ScrollView style={styles.modalContent} contentContainerStyle={styles.modalContentInner}>
              <View style={styles.modalSection}>
                <Text style={styles.modalSectionTitle}>Infos g√©n√©rales</Text>
                <Text style={styles.modalRow}><Text style={styles.modalLabel}>Num√©ro BL:</Text> {delivery.delivery_note_number ?? '‚Äî'}</Text>
                <Text style={styles.modalRow}><Text style={styles.modalLabel}>Date:</Text> {delivery.delivery_date ?? '‚Äî'}</Text>
              </View>

              <View style={styles.modalSection}>
                <Text style={styles.modalSectionTitle}>Exp√©diteur</Text>
                <Text style={styles.modalRow}>{delivery.shipper_name_address ?? '‚Äî'}</Text>
                <Text style={styles.modalRow}><Text style={styles.modalLabel}>SIRET:</Text> {delivery.shipper_siret ?? '‚Äî'}</Text>
              </View>

              <View style={styles.modalSection}>
                <Text style={styles.modalSectionTitle}>Destinataire</Text>
                <Text style={styles.modalRow}>{delivery.recipient_name_address ?? '‚Äî'}</Text>
                <Text style={styles.modalRow}><Text style={styles.modalLabel}>SIRET:</Text> {delivery.recipient_siret ?? '‚Äî'}</Text>
              </View>

              <View style={styles.modalSection}>
                <Text style={styles.modalSectionTitle}>Items ({delivery.items.length})</Text>
                {delivery.items.map((item, idx) => {
                  const key = (item.product_name ?? '').toUpperCase().trim();
                  const scanned = key ? labelCounts[key] ?? 0 : 0;
                  const expected = item.quantity ?? 0;
                  const isOk = scanned >= expected;
                  return (
                    <View key={idx} style={[styles.modalItem, isOk && styles.modalItemOk, !isOk && styles.modalItemKo]}>
                      <View style={styles.modalItemHeader}>
                        <View style={[styles.badge, isOk ? styles.badgeOk : styles.badgeKo]} />
                        <Text style={styles.modalItemName}>{item.product_name ?? 'Produit'}</Text>
                      </View>
                      <Text style={styles.modalItemDetail}>Vari√©t√©: {item.variety ?? '‚Äî'}</Text>
                      <Text style={styles.modalItemDetail}>Origine: {item.origin ?? '‚Äî'}</Text>
                      <Text style={styles.modalItemDetail}>Lot: {item.lot ?? '‚Äî'}</Text>
                      <Text style={styles.modalItemDetail}>Unit√©: {item.unit ?? '‚Äî'}</Text>
                      <Text style={[styles.modalItemDetail, {fontWeight: '600'}]}>
                        Scann√©es: {scanned} / Attendues: {expected}
                      </Text>
                    </View>
                  );
                })}
              </View>
            </ScrollView>

            <View style={styles.modalFooter}>
              <TouchableOpacity
                style={[styles.modalButton, styles.modalButtonSecondary]}
                onPress={() => setBlModalOpen(false)}
              >
                <Text style={styles.modalButtonText}>Fermer</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.modalButton, styles.modalButtonPrimary]}
                onPress={handleValidateBlScan}
              >
                <Text style={[styles.modalButtonText, {fontWeight: '700'}]}>Valider fin de scan</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      )}

      {/* Modal pour entrer une quantit√© manuelle */}
      {quantityModalOpen && quantityModalProduct && (
        <View style={styles.quantityInputModal}>
          <View style={styles.quantityInputBox}>
            <Text style={styles.quantityInputTitle}>
              Quantit√© pour {quantityModalProduct}
            </Text>
            <View>
              <Text style={styles.quantityInputLabel}>
                Entrez le nombre de colis scann√©s :
              </Text>
              <TextInput
                style={styles.quantityInputField}
                keyboardType="number-pad"
                placeholder="Ex: 20"
                placeholderTextColor="#6b7280"
                value={quantityInput}
                onChangeText={setQuantityInput}
                autoFocus
              />
            </View>
            <View style={styles.quantityInputButtons}>
              <TouchableOpacity
                style={[styles.quantityInputButton, styles.quantityInputButtonCancel]}
                onPress={() => {
                  setQuantityModalOpen(false);
                  setQuantityModalProduct(null);
                  setQuantityInput('1');
                }}
              >
                <Text style={styles.quantityInputButtonText}>Annuler</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.quantityInputButton, styles.quantityInputButtonConfirm]}
                onPress={handleAddQuantity}
              >
                <Text style={styles.quantityInputButtonText}>Ajouter</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      )}
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#0c0c0f',
  },
  cameraWrapper: {
    flex: 1,
    position: 'relative',
  },
  camera: {
    flex: 1,
  },
  overlay: {
    position: 'absolute',
    top: 24,
    left: 16,
    right: 16,
    backgroundColor: 'rgba(0,0,0,0.35)',
    padding: 12,
    borderRadius: 12,
  },
  guideFrame: {
    position: 'absolute',
    top: '25%',
    left: '10%',
    right: '10%',
    height: '50%',
    borderWidth: 2,
    borderColor: '#93c5fd',
    borderRadius: 12,
    backgroundColor: 'rgba(147,197,253,0.06)',
  },
  captureZone: {
    position: 'absolute',
    bottom: 24,
    left: 0,
    right: 0,
    alignItems: 'center',
  },
  shutter: {
    backgroundColor: '#f8fafc',
    paddingHorizontal: 28,
    paddingVertical: 12,
    borderRadius: 999,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 6,
  },
  shutterDisabled: {
    opacity: 0.5,
  },
  shutterText: {
    color: '#0c0c0f',
    fontWeight: '800',
    letterSpacing: 1,
  },
  title: {
    color: 'white',
    fontSize: 18,
    fontWeight: '600',
  },
  subtitle: {
    color: '#d7d7db',
    marginTop: 4,
  },
  bottomPanel: {
    padding: 16,
    backgroundColor: '#0c0c0f',
    borderTopWidth: 1,
    borderTopColor: '#1c1c20',
    gap: 8,
  },
  bottomPanelCollapsed: {
    paddingVertical: 8,
    paddingHorizontal: 16,
    height: 'auto',
    maxHeight: 50,
    overflow: 'hidden',
  },
  bottomPanelToggle: {
    paddingVertical: 6,
    paddingHorizontal: 10,
    alignSelf: 'center',
    marginBottom: 4,
  },
  bottomPanelToggleText: {
    color: '#93c5fd',
    fontWeight: '600',
    fontSize: 12,
  },
  row: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  label: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
  chip: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 999,
    backgroundColor: '#1c1c20',
  },
  chipActive: {
    backgroundColor: '#2563eb',
  },
  chipText: {
    color: 'white',
    fontWeight: '600',
  },
  separator: {
    height: 1,
    backgroundColor: '#1c1c20',
    marginVertical: 4,
  },
  scanCard: {
    backgroundColor: '#111118',
    borderRadius: 12,
    padding: 12,
    gap: 4,
  },
  scanType: {
    color: '#93c5fd',
    fontWeight: '700',
    letterSpacing: 0.5,
  },
  scanData: {
    color: 'white',
    fontSize: 16,
  },
  scanTime: {
    color: '#a1a1aa',
    fontSize: 12,
  },
  muted: {
    color: '#a1a1aa',
  },
  error: {
    color: '#f87171',
    fontWeight: '600',
  },
  link: {
    color: '#93c5fd',
    fontWeight: '600',
  },
  centered: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 24,
    gap: 12,
  },
  primaryButton: {
    backgroundColor: '#2563eb',
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderRadius: 10,
  },
  primaryButtonText: {
    color: 'white',
    fontWeight: '700',
  },
  modeSwitch: {
    flexDirection: 'row',
    gap: 8,
  },
  modeChip: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: '#111118',
  },
  modeChipActive: {
    backgroundColor: '#2563eb',
  },
  modeChipText: {
    color: 'white',
    fontSize: 12,
    fontWeight: '600',
  },
  historyBox: {
    marginTop: 8,
    backgroundColor: '#0f172a',
    borderRadius: 12,
    borderWidth: 1,
    borderColor: '#1c1c20',
    padding: 10,
  },
  historyTitle: {
    color: 'white',
    fontWeight: '700',
    marginBottom: 6,
  },
  historyList: {
    maxHeight: 220,
  },
  historyContent: {
    gap: 8,
  },
  historyItem: {
    backgroundColor: '#111118',
    borderRadius: 10,
    padding: 10,
    gap: 2,
  },
  historyHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  historyProduct: {
    color: 'white',
    fontWeight: '700',
  },
  historyMeta: {
    color: '#cbd5e1',
    fontSize: 12,
  },
  expandedBox: {
    marginTop: 6,
    backgroundColor: '#0f172a',
    borderRadius: 8,
    padding: 8,
    gap: 4,
  },
  expandedRow: {
    color: '#e2e8f0',
    fontSize: 12,
  },
  badge: {
    width: 12,
    height: 12,
    borderRadius: 6,
  },
  badgeOk: {
    backgroundColor: '#22c55e',
  },
  badgeKo: {
    backgroundColor: '#ef4444',
  },
  complianceRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    marginTop: 4,
  },
  complianceText: {
    color: '#e2e8f0',
    fontSize: 12,
  },
  uploadingInfo: {
    color: '#cbd5e1',
    marginTop: 6,
    fontSize: 12,
  },
  deliveryCard: {
    marginTop: 8,
    marginBottom: 4,
    backgroundColor: '#020617',
    borderRadius: 12,
    borderWidth: 1,
    borderColor: '#1c1c20',
    padding: 10,
    gap: 2,
  },
  deliveryTitle: {
    color: '#e5e7eb',
    fontWeight: '700',
    marginBottom: 4,
  },
  deliveryMeta: {
    color: '#9ca3af',
    fontSize: 12,
  },
  deliveryItem: {
    color: '#e5e7eb',
    fontSize: 12,
  },
  // Styles pour la modal BL
  modalOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0,0,0,0.7)',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 1000,
  },
  modal: {
    width: '90%',
    maxHeight: '80%',
    backgroundColor: '#111118',
    borderRadius: 16,
    borderWidth: 1,
    borderColor: '#1c1c20',
    overflow: 'hidden',
    flexDirection: 'column',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#1c1c20',
    backgroundColor: '#0f0f12',
  },
  modalTitle: {
    color: 'white',
    fontWeight: '700',
    fontSize: 16,
  },
  modalCloseButton: {
    color: '#9ca3af',
    fontSize: 20,
    fontWeight: '600',
  },
  modalContent: {
    flex: 1,
  },
  modalContentInner: {
    paddingHorizontal: 12,
    paddingVertical: 12,
    gap: 12,
  },
  modalSection: {
    gap: 6,
  },
  modalSectionTitle: {
    color: '#93c5fd',
    fontWeight: '700',
    fontSize: 14,
    marginBottom: 4,
  },
  modalRow: {
    color: '#e2e8f0',
    fontSize: 13,
    paddingVertical: 2,
  },
  modalLabel: {
    fontWeight: '600',
    color: '#cbd5e1',
  },
  modalItem: {
    backgroundColor: '#0f172a',
    borderRadius: 10,
    padding: 10,
    marginBottom: 8,
    borderLeftWidth: 3,
    borderLeftColor: '#6b7280',
  },
  modalItemOk: {
    borderLeftColor: '#22c55e',
  },
  modalItemKo: {
    borderLeftColor: '#ef4444',
  },
  modalItemHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    marginBottom: 6,
  },
  modalItemName: {
    color: 'white',
    fontWeight: '700',
    fontSize: 14,
  },
  modalItemDetail: {
    color: '#cbd5e1',
    fontSize: 12,
    marginVertical: 2,
  },
  modalFooter: {
    flexDirection: 'row',
    gap: 8,
    paddingHorizontal: 12,
    paddingVertical: 12,
    borderTopWidth: 1,
    borderTopColor: '#1c1c20',
    backgroundColor: '#0f0f12',
  },
  modalButton: {
    flex: 1,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  modalButtonPrimary: {
    backgroundColor: '#2563eb',
  },
  modalButtonSecondary: {
    backgroundColor: '#374151',
  },
  modalButtonText: {
    color: 'white',
    fontWeight: '600',
    fontSize: 13,
  },
  // Styles pour les contr√¥les de quantit√©
  quantityRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 8,
  },
  quantityControls: {
    flexDirection: 'row',
    gap: 6,
    alignItems: 'center',
  },
  quantityButton: {
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: '#2563eb',
    justifyContent: 'center',
    alignItems: 'center',
  },
  quantityButtonSmall: {
    width: 32,
    height: 32,
  },
  quantityButtonText: {
    color: 'white',
    fontWeight: '700',
    fontSize: 16,
  },
  // Modal quantit√© manuelle
  quantityInputModal: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0,0,0,0.7)',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 1001,
  },
  quantityInputBox: {
    width: '80%',
    backgroundColor: '#111118',
    borderRadius: 16,
    borderWidth: 1,
    borderColor: '#1c1c20',
    padding: 20,
    gap: 16,
  },
  quantityInputTitle: {
    color: 'white',
    fontWeight: '700',
    fontSize: 16,
  },
  quantityInputLabel: {
    color: '#cbd5e1',
    fontSize: 14,
    marginBottom: 8,
  },
  quantityInputField: {
    borderWidth: 1,
    borderColor: '#374151',
    borderRadius: 8,
    paddingHorizontal: 12,
    paddingVertical: 10,
    backgroundColor: '#0f0f12',
    color: 'white',
    fontSize: 14,
    fontWeight: '600',
  },
  quantityInputButtons: {
    flexDirection: 'row',
    gap: 8,
    marginTop: 8,
  },
  quantityInputButton: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 8,
    alignItems: 'center',
  },
  quantityInputButtonCancel: {
    backgroundColor: '#374151',
  },
  quantityInputButtonConfirm: {
    backgroundColor: '#2563eb',
  },
  quantityInputButtonText: {
    color: 'white',
    fontWeight: '600',
    fontSize: 13,
  },
});

